# 그리디 알고리즘 (Greedy Algorithm)

그리디 알고리즘은 전역적 최적해를 찾기 위해 각 단계에서 지역적으로 가장 좋은 선택을 하는 문제 해결 기법이다. 이때, **미래 상황을 고려하지 않고 현재 상태에서 보는 선택지 중 최선의 선택지를 선택**한다. 이 접근 방식은 효율적이고 간단할 수 있지만 모든 문제에 대해 최상의 결과를 보장하지는 않는다. 따라서 문제를 풀기 전에 greedy를 적용해도 되는 문제인지 확인하는 과정이 필요하다. 

<br>

## 그리디 알고리즘 이론
그리디 알고리즘은 다음과 같은 3단계를 반복하면서 문제를 해결한다. <br>
1. 해 선택: 현재 상태에서 가장 최선이라고 생각되는 해를 선택한다. 
2. 적절성 검사: 현재 선택한 해가 전체 문제의 제약 조건에 벗어나지 않는지 검사한 후, 선택한 옵션에 따라 새 상태로 이동한다. 
3. 현재까지 선택한 해 집합이 전체 문제를 해결할 수 있는지 검사한다. 최종 해답을 구하거나 문제가 막힐 때까지 1번으로 돌아가 같은 과정을 반복한다. 

## 그리디 알고리즘 특징
- 완전 탐색이 아니기 때문에 시간 복잡도 측면에서 효율적이고, DP와 다르게 계산된 내용을 저장해 둘 필요가 없으므로 공간 복잡도 측면에서도 효율적이다. 
- 항상 최적의 해를 보장하지는 않지만, 최적에 근사하는 해를 제공하기 때문에 정확도보다 속도 및 성능이 중요한 경우에 사용될 수 있다. 

### 그리디 알고리즘의 복잡도

<p align="center" style="padding: 10px 0px;">
<table style="text-align:center">
<tr>
<td>시간복잡도</td>
<td>공간 복잡도</td>
</tr>
<tr>
<td>일반적으로 O(nlogn) </td>
<td>일반적으로 O(n)</td>
</tr>
</table>
</p>

**[시간 복잡도]** <br>
greedy 알고리즘은 문제의 종류, 알고리즘의 구현 방법에 따라 복잡도가 달라진다. <br>
1. greedy 알고리즘은 초기 단계에서 데이터를 정렬하거나, 우선순위 큐를 활용하는 경우가 많다. 이때 O(nlogn) 또는 O(logn)의 시간이 걸린다. 
2. 반복적으로 하위 문제의 최적의 해를 선택한다. 이때 O(n) 또는 O(E+V)의 시간이 걸린다. <br>

따라서 일반적으로 O(nlogn)으로 볼 수 있지만, greedy 알고리즘은 그 자체로 문제를 해결하기 보다 다른 알고리즘의 기반이 되는 경우가 많기 때문에 복잡도를 잘 계산해보아야 한다. 

**[공간 복잡도]**<br>
기본적으로 N개의 입력 데이터를 저장하기 위해 O(N), MST나 최단 거리 알고리즘 등에서는 O(E+V)만큼의 공간이 필요하다. 정렬이나 우선순위 큐를 위해서 추가적인 배열을 위한 공간이 필요할 수도 있다. 


<br>

## 그리디 알고리즘 예시
1. **다익스트라 알고리즘**<br>
그래프에서 두 노드 사이의 최단 경로를 찾는다. 현재 노드를 거쳐가는 경우가 더 짧은 경우 그 경로를 선택하는 방식으로 경로를 정한다. 

2. **크루스칼 알고리즘**<br>
그래프의 최소 비용 신장 트리(MST)를 찾는다. 에지를 가중치 기준으로 오름차순 정렬한 후, 가장 가중치가 적은 에지부터 선택해 나가면서 사이클 생성 검사를 한다. 사이클을 생성하지 않을 경우 해당 에지를 선택한다. 

3. **부분 배낭 문제 (KnapSack Problem)**<br>
N개의 항목에 대해 무게와 가치가 주어졌을 때, 용량 W의 배낭에 항목을 넣어 최대의 이익을 얻는 방법이다. 무게 대비 가치가 높은 항목부터 배낭에 넣는다. 

4. **동전 선택 문제**<br>
N종류의 동전을 사용해 그 가격의 합이 K원이 되도록 할 때, 필요한 동전의 최솟값을 구한다. 즉 최대한 적은 동전 개수로 K원을 만들어야 한다. 

5. **허프만 코딩**<br>
각 문자의 빈도를 고려하여 이진 트리를 구성하고, 이 이진 트리를 활용하여 데이터를 압축할 수 있다. 더 자주 사용되는 문자에 더 짧은 코드를 할당하여 효율적으로 압축한다.
<a href="https://levelup.gitconnected.com/huffman-encoding-424d40d92f70">(참고)</a>


### 대표적인 동전 선택 문제를 살펴보자!

동전의 종류가 주어지고, 각 단위의 동전은 무한으로 사용할 수 있다. 이때 최소한의 동전을 사용해서 K원을 만들어야 한다. (K원은 무조건 주어진 동전 종류로 만들 수 있는 금액이다. )

#### 문제
**{1, 5, 10, 100}** 종류의 동전이 있을 때, 최소한의 동전을 사용해 236원을 만들어라. 

#### 풀이
남은 금액 M을 넘지 않는 동전 중 가장 큰 금액의 동전을 가능한 많이 선택한다. M에서 해당 금액을 제외한 금액에 대해, 같은 과정을 반복한다. 

#### 수식
동전의 종류는 아래와 같다.  $$d_1, d_2, ..., d_k \ \ (d_1 < d_2 < ... < d_k)$$

K원을 만들기 위해서, 가장 큰 동전부터 선택해 나간다. 남은 금액 r에 대해서도 같은 과정을 반복한다. 
$$K = q*d_k + r \ \ (0 \le r \le d_k )$$

#### 코드 (Java)
```java
public class FindMinCoin {
    static int coin[] = {1, 5, 10, 100};
    static int n = coin.length;

    static void findMin(int V)
    {
        for (int i = n - 1; i >= 0; i--)
        {
            int ans = 0;
            while (V >= coin[i])
            {
                V -= coin[i];
                ans++;
            }
            System.out.println(coin[i]+"원 짜리 동전 "+ans+"개");
        }

    }

    public static void main(String[] args)
    {
        int n = 236;
        System.out.println(
                "minimal number "
                        +"of change for " + n + ": ");
        findMin(n);
    }
}
```
<br>
작은 금액의 동전을 여러 개 선택하는 것보다 큰 금액의 동전부터 선택하는 것이 최소한의 동전을 선택할 수 있는 방법이므로, 현재 상태에서 가장 큰 금액의 동전부터 선택해나가는 그리디 알고리즘으로 해결할 수 있다. 
<br>
하지만 동전 탐색 문제에서 greedy 알고리즘이 항상 최적의 해를 보장하는 것은 아니다. greedy가 최적의 해를 보장하기 위해서는 두 가지 조건이 충족되어야 하는데, 각 동전이 이전 동전의 배수가 아닐 경우 두 조건 중 '최적 부분 구조'를 만족하기 않기 때문에 greedy로 최적해를 보장할 수 없다. 
<br>

예를 들어, {1, 3, 4}원의 동전이 있다고 하고, 이 동전을 활용해 6원을 만들어야 한다고 가정하자. 이때 각 4는 3의 배수가 아니므로 greedy를 적용했을 때 최적해를 보장하지 않는 것을 확인할 수 있다. greedy로 해결하면 4x1 + 1x2로 총 3개의 동전을 사용하게 되지만 최적해는 3원 짜리 2개를 사용하는 것이다. 


## 그리디 알고리즘이 최적해를 보장하는 경우
아래 두 조건을 만족해야 greedy가 최적해를 보장할 수 있다. 
1. 최적 부분 구조(Optimal Substructure): 문제의 최적해가 하위 문제들의 최적해로 구성되는지 확인한다. 즉, 전체 문제의 솔루션에 하위 문제 솔루션이 포함되는지 확인한다. 
2. 탐욕적 선택 속성(Greedy Choice Property): 각 단계에서 최적의 선택을 하는 것이 전체 문제를 해결하는 최적해로 이어질 수 있어야 한다. 

## 그리디가 최적해를 보장하는지, 그리디를 적용해도 되는 문제인지 어떻게 판단하는가
1. 가장 현실적이고 확실한 방법으로는 그리디 알고리즘 문제를 많이 풀어보고 문제 유형을 기억해두는 것이다. (MST, 최단 경로 탐색 등)

2. 관찰을 통해 그리디 알고리즘이 적용될 수 있는지 판단하고 구현한 후, 최적해인지 판단한다. 최적해를 보장하는지 확인할 때는 수학적으로 증명하거나, 여러 테스트 케이스를 직접 입력해보며 확인하거나, DP와 같이 항상 최적해를 보장하는 다른 알고리즘을 활용해 출력 결과를 비교해볼 수 있다. 

<br>

![alt text](./image/그리디알고리즘%20전략.png)
<a href="https://blog.encrypted.gg/975">바킹독 참고</a>