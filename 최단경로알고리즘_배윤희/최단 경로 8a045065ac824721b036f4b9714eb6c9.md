# 최단 경로

## 다익스트라 알고리즘 (그리디 알고리즘에 해당)

그래프에서 여러 개의 노드가 있을때, **특정한 노드**에서 출발하여 다른 노드로 가는 **각각의 최단 경로**를 구해주는 알고리즘이다.

가중 그래프에서 **간선 가중치의 합이 최소가 되는 경로**를 찾는 알고리즘 

1. 출발 노드를 설정하고, 최단 거리 테이블을 초기화한다.
2. 방문하지 않은 노드 중에서 최단 거리가 짧은 노드를 선택한다.
3. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
4. 2번, 3번을 반복한다.

출발 노드가 1이고, 출발노드를 제외한 다른 노드로의 최단 거리를 무한으로 초기화함

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled.png)

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%201.png)

1번 노드를 거쳐 다른 노드로 가는 비용을 계산한다. 1번 노드와 연결된 모든 간선을 확인하고, 전부 무한보다 짧은 경로이기 때문에 새로운 값으로 갱신한다.

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%202.png)

1번 노드를 방문처리하고, 최단 거리가 가장 짧은 4번 노드를 선택한다.

4번 노드를 거쳐 갈 수 있는 노드는 3번과 5번이고, 최소비용은 4(1+3), 2(1+1)로 기존 리스트값보다 작으므로 리스트를 갱신한다.

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%203.png)

4번 노드를 방문처리하고, 2번 노드를 선택하지만 값이 갱신되지 않는다.

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%204.png)

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%205.png)

5번 노드를 방문하고, 3번 노드, 6번 노드로 가는 값을 갱신한다.

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%206.png)

3번 노드 방문, 갱신 안됨

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%207.png)

모든 노드 방문 완료

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%208.png)

### 간단한 다익스트라 알고리즘

O(V^2)의 시간 복잡도를 가진다.

O(V)번에 걸쳐서 최단 거리가 가장 짧은 노드를 선형 탐색하며 현재 노드와 연결된 노드를 일일이 확인하기 때문에, 전체 노드의 개수가 5000개 이하일 때 적합한 방법이다.

노드의 개수가 10000개를 넘어간다면 이 코드로는 문제를 해결하기 어렵다.

노드 및 간선의 개수가 많을 떄에는 개선된 다익스트라 알고리즘을 이용한다.

```java
import java.util.*;

class Node {

    private int index;
    private int distance;

    public Node(int index, int distance) {
        this.index = index;
        this.distance = distance;
    }

    public int getIndex() {
        return this.index;
    }

    public int getDistance() {
        return this.distance;
    }
}

public class Main {

    public static final int INF = (int) 1e9; // 무한을 의미하는 값으로 10억을 설정
    // 노드의 개수(N), 간선의 개수(M), 시작 노드 번호(Start)
    // 노드의 개수는 최대 100,000개라고 가정
    public static int n, m, start;
    // 각 노드에 연결되어 있는 노드를 정보를 리스트에 담기 
    public static ArrayList<ArrayList<Node>> graph = new ArrayList<ArrayList<Node>>();
    // 방문한 적이 있는지 체크하는 목적의 배열 만들기
    public static boolean[] visited = new boolean[100001];
    // 최단 거리 테이블 만들기
    public static int[] d = new int[100001];

    // 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환
    public static int getSmallestNode() {
        int min_value = INF;
        int index = 0; // 가장 최단 거리가 짧은 노드(인덱스)
        for (int i = 1; i <= n; i++) {
            if (d[i] < min_value && !visited[i]) {
                min_value = d[i];
                index = i;
            }
        }
        return index;
    }

    public static void dijkstra(int start) {
        // 시작 노드에 대해서 초기화
        d[start] = 0;
        visited[start] = true;
        // 시작 노드와 연결된 노드와의 비용을 d에 저장
        for (int j = 0; j < graph.get(start).size(); j++) {
            d[graph.get(start).get(j).getIndex()] = graph.get(start).get(j).getDistance();
        }
        // 시작 노드를 제외한 전체 n - 1개의 노드에 대해 반복
        for (int i = 0; i < n - 1; i++) {
            // 현재 최단 거리가 가장 짧은 노드를 꺼내서, 방문 처리
            int now = getSmallestNode();
            visited[now] = true;
            // 현재 노드와 연결된 다른 노드를 확인
            for (int j = 0; j < graph.get(now).size(); j++) {
            //현재 최단 거리가 가장 짧은 노드 + 그 노드와 연결된 노드와의 비용 계산
                int cost = d[now] + graph.get(now).get(j).getDistance();
                // 현재 노드를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
                if (cost < d[graph.get(now).get(j).getIndex()]) {
                    d[graph.get(now).get(j).getIndex()] = cost;
                }
            }
        }
    }

    public static void main(String[] args) throws IOException {
		    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		    StringTokenizer st = new StringTokenizer(br.readLine());
		    n = Integer.parseInt(st.nextToken());
		    m = Integer.parseInt(st.nextToken());
		    start = Integer.parseInt(st.nextToken());

        // 그래프 초기화
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<Node>());
        }

        // 모든 간선 정보를 입력받기
        for (int i = 0; i < m; i++) {
				st = new StringTokenizer(br.readLine());
		    a = Integer.parseInt(st.nextToken());
		    b = Integer.parseInt(st.nextToken());
		    c = Integer.parseInt(st.nextToken());
            // a번 노드에서 b번 노드로 가는 비용이 c라는 의미
            graph.get(a).add(new Node(b, c));
        }

        // 최단 거리 테이블을 모두 무한으로 초기화
        Arrays.fill(d, INF);
        
        // 다익스트라 알고리즘을 수행
        dijkstra(start);

        // 모든 노드로 가기 위한 최단 거리를 출력
        for (int i = 1; i <= n; i++) {
            // 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
            if (d[i] == INF) {
                System.out.println("INFINITY");
            }
            // 도달할 수 있는 경우 거리를 출력
            else {
                System.out.println(d[i]);
            }
        }
    }
}
```

### 개선된 다익스트라 알고리즘

**우선순위 큐**를 사용한 코드. 우선순위 큐를 이용해 최단 거리가 짧은 노드를 선형적으로 찾지 않고 더욱 빠르게 찾을 수 있다. 자바의 우선순위 큐는 힙 방식으로 구현되어 있어 이를 사용하면 노드를 찾는 데에 logN의 시간이 걸린다.

리스트로도 우선순위 큐를 구현할 수 있지만, 힙이 이진 트리 형태이기 때문에 더 효율적이다.

데이터의 개수가 N개일 때 리스트와 힙의 시간복잡도는 다음과 같다.

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%209.png)

힙 정렬시 최대(최소)힙을 만드는 연산 O(logN)을 N번 반복하므로 시간복잡도가 O(NlogN)이다.

개선된 다익스트라 알고리즘은 최악의 경우에도 O(ElogV)의 시간복잡도를 보장한다.

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled.png)

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%201.png)

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2010.png)

우선순위 큐에 1번 노드를 넣는다.

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2011.png)

1번 노드(0, 1)를 꺼낸 뒤, 1번 노드를 거쳐서 2, 3, 4번 노드로 가는 최단 거리를 갱신한다. 우선순위 큐는 거리가 짧은 순으로 저장된다.

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2012.png)

노드 4 (1, 4)가 추출된다. 노드 3, 5가 갱신된다.

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2013.png)

노드 2 (2,2)가 추출된다. 아무것도 갱신되지 않는다.

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/c416c967-8062-4044-ab36-af3405520fad.png)

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2014.png)

노드 5 (2, 5)가 추출된다. 3번 노드, 6번 노드로 가는 최단거리가 갱신된다. 노드3(4, 3), 노드 6(4, 6)이 큐에 삽입된다.

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2015.png)

노드 3 (3, 3)을 꺼내고, 최단거리는 갱신되지 않는다.

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2016.png)

노드 3(4,3)을 꺼내도 갱신되지 않는다

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2017.png)

노드 6(4, 6), 노드 3(5, 3) 마찬가지로 갱신되지 않는다.

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2018.png)

```java
import java.util.*;

class Node implements Comparable<Node> {

    private int index;
    private int distance;

    public Node(int index, int distance) {
        this.index = index;
        this.distance = distance;
    }

    public int getIndex() {
        return this.index;
    }

    public int getDistance() {
        return this.distance;
    }

    // 거리(비용)가 짧은 것이 높은 우선순위를 가지도록 설정
    @Override
    public int compareTo(Node other) {
        if (this.distance < other.distance) {
            return -1;
        }
        return 1;
    }
}

public class Main {

    public static final int INF = (int) 1e9; // 무한을 의미하는 값으로 10억을 설정
    // 노드의 개수(N), 간선의 개수(M), 시작 노드 번호(Start)
    // 노드의 개수는 최대 100,000개라고 가정
    public static int n, m, start;
    // 각 노드에 연결되어 있는 노드에 대한 정보를 담는 배열
    public static ArrayList<ArrayList<Node>> graph = new ArrayList<ArrayList<Node>>();
    // 최단 거리 테이블 만들기
    public static int[] d = new int[100001];

    public static void dijkstra(int start) {
        PriorityQueue<Node> pq = new PriorityQueue<>();
        // 시작 노드로 가기 위한 최단 경로는 0으로 설정하여, 큐에 삽입
        pq.offer(new Node(start, 0));
        d[start] = 0;
        while(!pq.isEmpty()) { // 큐가 비어있지 않다면
            // 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
            Node node = pq.poll();
            int dist = node.getDistance(); // 현재 노드까지의 비용 
            int now = node.getIndex(); // 현재 노드
            // 현재 노드가 이미 처리된 적이 있는 노드라면 무시
            if (d[now] < dist) continue;
            // 현재 노드와 연결된 다른 인접한 노드들을 확인
            for (int i = 0; i < graph.get(now).size(); i++) {
                int cost = d[now] + graph.get(now).get(i).getDistance();
                // 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
                if (cost < d[graph.get(now).get(i).getIndex()]) {
                    d[graph.get(now).get(i).getIndex()] = cost;
                    pq.offer(new Node(graph.get(now).get(i).getIndex(), cost));
                }
            }
        }
    }

    public static void main(String[] args) {
		    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		    StringTokenizer st = new StringTokenizer(br.readLine());
		    n = Integer.parseInt(st.nextToken());
		    m = Integer.parseInt(st.nextToken());
		    start = Integer.parseInt(st.nextToken());

        // 그래프 초기화
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<Node>());
        }

        // 모든 간선 정보를 입력받기
        for (int i = 0; i < m; i++) {
				st = new StringTokenizer(br.readLine());
		    a = Integer.parseInt(st.nextToken());
		    b = Integer.parseInt(st.nextToken());
		    c = Integer.parseInt(st.nextToken());
            // a번 노드에서 b번 노드로 가는 비용이 c라는 의미
            graph.get(a).add(new Node(b, c));
        }

        // 최단 거리 테이블을 모두 무한으로 초기화
        Arrays.fill(d, INF);
        
        // 다익스트라 알고리즘을 수행
        dijkstra(start);

        // 모든 노드로 가기 위한 최단 거리를 출력
        for (int i = 1; i <= n; i++) {
            // 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
            if (d[i] == INF) {
                System.out.println("INFINITY");
            }
            // 도달할 수 있는 경우 거리를 출력
            else {
                System.out.println(d[i]);
            }
        }
    }
}
```

O(ElogV)의 시간복잡도를 보장하는 이유

while(!pq.isEmpty())가 노드 개수(V) 이상의 횟수로 반복되지 않는다. 

V번 반복될 때마다 연결된 간선을 모두 확인하기 때문에 최대 E만큼 연산된다.

따라서 E개의 원소를 우선순위 큐에 모두 넣었다가 모두 빼내는 연산을 수행하기 때문에, O(ElogE)의 시간 복잡도를 가진다.

그리고 모든 노드끼리 연결되어 있다고 했을 때 최대 간선의 개수는 V^2이기 떄문에 간선 데이터를 힙에 넣었다가 빼는 연산은 O(logV^2)이고 이는 O(logV)와 같다.

따라서 시간복잡도가 O(ElogV)가 된다.

**입력 예시**

```java
6 11
1
1 2 2
1 3 5
1 4 1
2 3 3
2 4 2
3 2 3
3 6 5
4 3 3
4 5 1
5 3 1
5 6 2
```

**출력 예시**

```java
0
2
3
1
2
4
```

## 플로이드 워셜 알고리즘

다익스트라 알고리즘은 한 지점에서 다른 특정 지점까지의 최단 경로를 구하는 알고리즘이었다.

플로이드 워셜 알고리즘은 **모든 지점에서 다른 모든 지점까지의 최단 경로를 구하는 경우**에 사용하는 알고리즘이다.

단계마다 최단 거리를 갖는 노드를 하나씩 반복적으로 선택하고, 해당 노드를 거쳐 가는 경로를 확인하여 최단거리 테이블을 갱신한다.

점화식은 다음과 같다.

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2019.png)

방문하지 않은 노드를 확인하지 않기 때문에, 노드의 개수가 N개일 때 N번의 단계를 수행하며, 단계마다 O(N^2)의 연산을 통해 현재 노드를 거치는 모든 경로를 고려한다.

총 시간복잡도는 O(N^3)이다.

다익스트라 알고리즘은 출발 노드가 1개이고 최단 거리를 저장하기 위해 1차원 리스트를 이용했다.

**플로이드 워셜 알고리즘**은 **2차원 리스트에 최단 거리 정보를 저장**한다. 단계마다 **O(N^2)연산**이 수행되는 이유이다.

다익스트라 알고리즘은 **그리디 알고리즘**이며, 플로이드 워셜 알고리즘은 **다이나믹 프로그래밍**이다.

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2020.png)

예시 그래프를 바탕으로 초기 테이블을 설정할 수 있다.

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2021.png)

1번을 거쳐 가는 점화식

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2022.png)

하늘색으로 색칠된 부분이 점화식에 해당하는 부분이다. 하늘색에 해당하는 값을 갱신해준다.

(1을 경유해서 가는 경우)

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2023.png)

2를 경유해서 갈 수 있는 경우

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/4ea48d0c-e862-4679-9e85-c5bdf11decd7.png)

3을 경유해서 가는 경우

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2024.png)

4를 경유해서 가는 경우

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2025.png)

최종 결과

![Untitled](%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%20%E1%84%80%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A9%208a045065ac824721b036f4b9714eb6c9/Untitled%2026.png)

```java
import java.util.*;

public class Main {

    public static final int INF = (int) 1e9; // 무한을 의미하는 값으로 10억을 설정
    // 노드의 개수(N), 간선의 개수(M)
    // 노드의 개수는 최대 500개라고 가정
    public static int n, m;
    // 2차원 배열(그래프 표현)를 만들기
    public static int[][] graph = new int[501][501];

    public static void main(String[] args) {
		    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		    StringTokenizer st = new StringTokenizer(br.readLine());
		    n = Integer.parseInt(st.nextToken());
		    m = Integer.parseInt(st.nextToken());

        // 최단 거리 테이블을 모두 무한으로 초기화
        for (int i = 0; i < 501; i++) {
            Arrays.fill(graph[i], INF);
        }

        // 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
        for (int a = 1; a <= n; a++) {
            for (int b = 1; b <= n; b++) {
                if (a == b) graph[a][b] = 0;
            }
        }

        // 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화
        for (int i = 0; i < m; i++) {
            // A에서 B로 가는 비용은 C라고 설정
						st = new StringTokenizer(br.readLine());
				    a = Integer.parseInt(st.nextToken());
				    b = Integer.parseInt(st.nextToken());
				    c = Integer.parseInt(st.nextToken());
            graph[a][b] = c;
        }

        // 점화식에 따라 플로이드 워셜 알고리즘을 수행
        for (int k = 1; k <= n; k++) {
            for (int a = 1; a <= n; a++) {
                for (int b = 1; b <= n; b++) {
                    graph[a][b] = Math.min(graph[a][b], graph[a][k] + graph[k][b]);
                }
            }
        }

        // 수행된 결과를 출력
        for (int a = 1; a <= n; a++) {
            for (int b = 1; b <= n; b++) {
                // 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
                if (graph[a][b] == INF) {
                    System.out.print("INFINITY ");
                }
                // 도달할 수 있는 경우 거리를 출력
                else {
                    System.out.print(graph[a][b] + " ");
                }
            }
            System.out.println();
        }
    }
}
```

**입력 예시**

```java
4
7
1 2 4
1 4 6
2 1 3
2 3 7
3 1 5
3 4 4
4 3 2
```

**출력 예시**

```java
0 4 8 6
3 0 7 9
5 9 0 4
7 11 2 0
```